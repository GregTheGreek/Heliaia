/** @license React v2.5.1
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';function U(a){return"Identifier"===a.type?/^use[A-Z0-9].*$/.test(a.name):"MemberExpression"===a.type&&!a.computed&&U(a.property)?(a=a.object,"Identifier"===a.type&&"React"===a.name):!1}function ca(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function da(a,e){return a.name===e||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===e}function ea(a){return!!(a.parent&&a.parent.callee&&da(a.parent.callee,"forwardRef"))}
function fa(a){return!!(a.parent&&a.parent.callee&&da(a.parent.callee,"memo"))}function ha(a){for(;a;){var e=ia(a);if(e&&(ca(e)||U(e))||ea(a)||fa(a))return!0;a=a.parent}return!1}
function ia(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function W(a){function e(){return{isRequired:!1,isSatisfiedRecursively:!1,hasRequiredNodesBelow:!1,children:new Map}}function b(a,d){d=d.split(".");var k=!0,l=!1,b=void 0;try{for(var g=d[Symbol.iterator](),q;!(k=(q=g.next()).done);k=!0){var m=q.value,x=a.children.get(m);x||(x=e(),a.children.set(m,x));a=x}}catch(D){l=!0,b=D}finally{try{k||null==g.return||g.return()}finally{if(l)throw b;}}return a}function g(a,d,e){d=d.split(".");var k=!0,l=!1,b=void 0;try{for(var g=d[Symbol.iterator](),x;!(k=(x=g.next()).done);k=
!0){var m=a.children.get(x.value);if(!m)break;e(m);a=m}}catch(D){l=!0,b=D}finally{try{k||null==g.return||g.return()}finally{if(l)throw b;}}}function d(a,e,l,g){a.children.forEach(function(a,k){var b=g(k);a.isSatisfiedRecursively?a.hasRequiredNodesBelow&&l.add(b):a.isRequired?e.add(b):d(a,e,l,function(a){return b+"."+a})})}var x=a.dependencies,n=a.declaredDependencies,y=a.optionalDependencies,l=a.externalDependencies,E=a.isEffect,F=e();x.forEach(function(a,d){b(F,d).isRequired=!0;g(F,d,function(a){a.hasRequiredNodesBelow=
!0})});n.forEach(function(a){b(F,a.key).isSatisfiedRecursively=!0});y.forEach(function(a){b(F,a).isSatisfiedRecursively=!0});a=new Set;var m=new Set;d(F,a,m,function(a){return a});var t=[],A=new Set,B=new Set;n.forEach(function(a){a=a.key;m.has(a)?-1===t.indexOf(a)?t.push(a):B.add(a):!E||a.endsWith(".current")||l.has(a)?A.add(a):-1===t.indexOf(a)&&t.push(a)});a.forEach(function(a){t.push(a)});return{suggestedDependencies:t,unnecessaryDependencies:A,duplicateDependencies:B,missingDependencies:a}}
function ja(a){var e=a.declaredDependenciesNode,b=a.componentScope,g=a.scope;return a.declaredDependencies.map(function(a){a=b.set.get(a.key);if(null==a)return null;var d=a.defs[0];return null==d?null:"Variable"===d.type&&"VariableDeclarator"===d.node.type&&null!=d.node.init&&("ArrowFunctionExpression"===d.node.init.type||"FunctionExpression"===d.node.init.type)||"FunctionName"===d.type&&"FunctionDeclaration"===d.node.type?a:null}).filter(Boolean).map(function(a){var d=a.defs[0];a:{for(var b=!1,y=
0;y<a.references.length;y++){var l=a.references[y];if(l.writeExpr)if(b){a=!0;break a}else{b=!0;continue}for(var E=l.from;E!==g&&null!=E;)E=E.upper;if(E!==g&&!ka(e,l.identifier)){a=!0;break a}}a=!1}return{fn:d,suggestUseCallback:a}})}function la(a){return"MemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&"CallExpression"===a.parent.parent.type&&a.parent.parent.callee===a.parent?a:la(a.parent)}
function Y(a){if("Identifier"===a.type)return a.name;if("MemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var e=Y(a.object);a=Y(a.property);return e+"."+a}function ma(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function na(a,e){var b=ma(a);if("Identifier"!==b.type)return null;switch(b.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(b===a&&e&&e.additionalHooks){try{var g=Y(b)}catch(d){if(/Unsupported node type/.test(d.message))return 0;throw d;}return e.additionalHooks.test(g)?0:-1}return-1}}
function Z(a,e){for(var b=[a],g=null;b.length;){g=b.shift();if("Identifier"===g.type&&g.name===e.name&&g.range[0]===e.range[0]&&g.range[1]===e.range[1])return g;if(ka(g,e)){a=0;for(var d=Object.entries(g);a<d.length;a++){var x=d[a],n=x[1];"parent"!==x[0]&&(oa(n)?(n.parent=g,b.push(n)):Array.isArray(n)&&n.forEach(function(a){oa(a)&&(a.parent=g,b.push(a))}))}}}return null}
function pa(a){for(var e="",b=0;b<a.length;b++)e+=a[b],0===b&&2===a.length?e+=" and ":b===a.length-2&&2<a.length?e+=", and ":b<a.length-1&&(e+=", ");return e}function oa(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function ka(a,e){return a.range[0]<=e.range[0]&&a.range[1]>=e.range[1]}
module.exports={__proto__:null,rules:{"rules-of-hooks":{create:function(a){var e=[],b=[];return{onCodePathSegmentStart:function(a){return b.push(a)},onCodePathSegmentEnd:function(){return b.pop()},onCodePathStart:function(){return e.push(new Map)},onCodePathEnd:function(b,d){function g(a,d){var c=g.cache,h=c.get(a.id);d=new Set(d);if(d.has(a.id)){c=[].concat(d);a=c.slice(c.indexOf(a.id)+1);c=!0;h=!1;var f=void 0;try{for(var r=a[Symbol.iterator](),M;!(c=(M=r.next()).done);c=!0)E.add(M.value)}catch(J){h=
!0,f=J}finally{try{c||null==r.return||r.return()}finally{if(h)throw f;}}return 0}d.add(a.id);if(void 0!==h)return h;if(b.thrownSegments.includes(a))h=0;else if(0===a.prevSegments.length)h=1;else{h=0;r=!0;M=!1;var e=void 0;try{f=a.prevSegments[Symbol.iterator]();for(var l;!(r=(l=f.next()).done);r=!0)h+=g(l.value,d)}catch(J){M=!0,e=J}finally{try{r||null==f.return||f.return()}finally{if(M)throw e;}}}a.reachable&&0===h?c.delete(a.id):c.set(a.id,h);return h}function n(a,d){var c=n.cache,h=c.get(a.id);
d=new Set(d);if(d.has(a.id)){c=Array.from(d);a=c.slice(c.indexOf(a.id)+1);c=!0;h=!1;var f=void 0;try{for(var r=a[Symbol.iterator](),e;!(c=(e=r.next()).done);c=!0)E.add(e.value)}catch(J){h=!0,f=J}finally{try{c||null==r.return||r.return()}finally{if(h)throw f;}}return 0}d.add(a.id);if(void 0!==h)return h;if(b.thrownSegments.includes(a))h=0;else if(0===a.nextSegments.length)h=1;else{h=0;r=!0;e=!1;var l=void 0;try{f=a.nextSegments[Symbol.iterator]();for(var g;!(r=(g=f.next()).done);r=!0)h+=n(g.value,
d)}catch(J){e=!0,l=J}finally{try{r||null==f.return||f.return()}finally{if(e)throw l;}}}c.set(a.id,h);return h}function y(a){var d=y.cache,c=d.get(a.id);if(null===c)return Infinity;if(void 0!==c)return c;d.set(a.id,null);if(0===a.prevSegments.length)c=1;else{c=Infinity;var h=!0,f=!1,r=void 0;try{for(var e=a.prevSegments[Symbol.iterator](),b;!(h=(b=e.next()).done);h=!0){var l=y(b.value);l<c&&(c=l)}}catch(J){f=!0,r=J}finally{try{h||null==e.return||e.return()}finally{if(f)throw r;}}c+=1}d.set(a.id,c);
return c}var l=e.pop();if(0!==l.size){var E=new Set;g.cache=new Map;n.cache=new Map;y.cache=new Map;var F=n(b.initialSegment),m=ia(d),t=ha(d),A=m?ca(m)||U(m):ea(d)||fa(d),B=Infinity,k=!0,q=!1,I=void 0;try{for(var w=b.finalSegments[Symbol.iterator](),L;!(k=(L=w.next()).done);k=!0){var X=L.value;if(X.reachable){var T=y(X);T<B&&(B=T)}}}catch(G){q=!0,I=G}finally{try{k||null==w.return||w.return()}finally{if(q)throw I;}}k=!0;q=!1;I=void 0;try{for(var z=l[Symbol.iterator](),Q;!(k=(Q=z.next()).done);k=!0){var D=
Q.value,C=D[0],N=D[1];if(C.reachable){var K=0===C.nextSegments.length?B<=y(C):B<y(C),R=g(C)*n(C),H=E.has(C.id);l=!0;w=!1;L=void 0;try{for(var v=N[Symbol.iterator](),O;!(l=(O=v.next()).done);l=!0){var p=O.value;H&&a.report({node:p,message:'React Hook "'+a.getSource(p)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(A){if(!H&&R!==F){var V='React Hook "'+a.getSource(p)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+
(K?" Did you accidentally call a React Hook after an early return?":"");a.report({node:p,message:V})}}else if(!d.parent||"MethodDefinition"!==d.parent.type&&"ClassProperty"!==d.parent.type||d.parent.value!==d)if(m){var P='React Hook "'+a.getSource(p)+'" is called in function "'+(a.getSource(m)+'" that is neither a React function component nor a custom React Hook function.');a.report({node:p,message:P})}else if("Program"===d.type){var S='React Hook "'+a.getSource(p)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:p,message:S})}else if(t){var u='React Hook "'+a.getSource(p)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:p,message:u})}}}catch(G){w=!0,L=G}finally{try{l||null==v.return||v.return()}finally{if(w)throw L;}}}}}catch(G){q=!0,I=G}finally{try{k||null==z.return||z.return()}finally{if(q)throw I;}}}},CallExpression:function(a){if(U(a.callee)){var d=e[e.length-1],g=b[b.length-1],n=d.get(g);n||
(n=[],d.set(g,n));n.push(a.callee)}}}}},"exhaustive-deps":{meta:{schema:[{type:"object",additionalProperties:!1,properties:{additionalHooks:{type:"string"}}}]},create:function(a){function e(a,d){return function(e){if(d.has(e))return d.get(e);var b=a(e);d.set(e,b);return b}}function b(b){function l(a){var c=!0,f=!1,r=void 0;try{for(var d=a.references[Symbol.iterator](),e;!(c=(e=d.next()).done);c=!0){var g=e.value;if(g.resolved&&I.has(g.resolved.scope)){var m=Z(b,g.identifier),k=la(m),n=Y(k),q;if(q=
B&&"Identifier"===k.type&&"MemberExpression"===k.parent.type&&!k.parent.computed&&"Identifier"===k.parent.property.type&&"current"===k.parent.property.name){for(var p=g.from,u=!1;p.block!==b;)"function"===p.type&&(u=null!=p.block.parent&&"ReturnStatement"===p.block.parent.type),p=p.upper;q=u}q&&T.set(n,{reference:g,dependencyNode:k});var t=g.resolved.defs[0];if(null!=t&&(null==t.node||t.node.init!==b.parent)&&"TypeParameter"!==t.type)if(z.has(n))z.get(n).references.push(g);else{var w=g.resolved,x=
L(w)||X(w);z.set(n,{isStatic:x,references:[g]})}}}}catch(ba){f=!0,r=ba}finally{try{c||null==d.return||d.return()}finally{if(f)throw r;}}c=!0;f=!1;r=void 0;try{for(var v=a.childScopes[Symbol.iterator](),y;!(c=(y=v.next()).done);c=!0)l(y.value)}catch(ba){f=!0,r=ba}finally{try{c||null==v.return||v.return()}finally{if(f)throw r;}}}function F(a,h,f,d){return 0===a.size?null:(1<a.size?"":h+" ")+f+" "+(1<a.size?"dependencies":"dependency")+": "+pa(Array.from(a).sort().map(function(a){return"'"+a+"'"}))+
(". Either "+d+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}if(("FunctionExpression"===b.type||"ArrowFunctionExpression"===b.type)&&"CallExpression"===b.parent.type){var m=na(b.parent.callee,g);if(b.parent.arguments[m]===b){var t=b.parent.callee,A=ma(t).name,B=/Effect($|[^a-z])/g.test(A),k=b.parent.arguments[m+1];if(k||B){B&&b.async&&a.report({node:b,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"});
var q=a.getScope(),I=new Set,w=null;for(m=q.upper;m;){I.add(m);if("function"===m.type)break;m=m.upper}if(m){w=m;var L=e(function(a){if(!Array.isArray(a.defs))return!1;var c=a.defs[0];if(null==c||"VariableDeclarator"!==c.node.type)return!1;var f=c.node.init;if(null==f)return!1;var b=c.node.parent;if(null==b&&(Z(w.block,c.node.id),b=c.node.parent,null==b))return!1;if("const"===b.kind&&"Literal"===f.type&&("string"===typeof f.value||"number"===typeof f.value||null===f.value))return!0;if("CallExpression"!==
f.type)return!1;f=f.callee;"MemberExpression"!==f.type||"React"!==f.object.name||null==f.property||f.computed||(f=f.property);if("Identifier"!==f.type)return!1;c=c.node.id;f=f.name;if("useRef"===f&&"Identifier"===c.type)return!0;if(("useState"===f||"useReducer"===f)&&"ArrayPattern"===c.type&&2===c.elements.length&&Array.isArray(a.identifiers)){if(c.elements[1]===a.identifiers[0]){if("useState"===f)for(a=a.references,f=0;f<a.length;f++)d.set(a[f].identifier,c.elements[0]);return!0}if(c.elements[0]===
a.identifiers[0]&&"useState"===f)for(a=a.references,c=0;c<a.length;c++)x.add(a[c].identifier)}return!1},n),X=e(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var c=a.node,f=w.childScopes;a=null;var b;for(b=0;b<f.length;b++){var d=f[b],e=d.block;if("FunctionDeclaration"===c.type&&e===c||"VariableDeclarator"===c.type&&e.parent===c){a=d;break}}if(null==a)return!1;for(b=0;b<a.through.length;b++)if(c=a.through[b],null!=c.resolved&&I.has(c.resolved.scope)&&
!L(c.resolved))return!1;return!0},y),T=new Map,z=new Map;l(q);T.forEach(function(c,b){var f=c.dependencyNode;c=c.reference.resolved.references;for(var d=!1,e=0;e<c.length;e++){var h=c[e].identifier.parent;if(null!=h&&"MemberExpression"===h.type&&!h.computed&&"Identifier"===h.property.type&&"current"===h.property.name&&"AssignmentExpression"===h.parent.type&&h.parent.left===h){d=!0;break}}d||a.report({node:f.parent.property,message:"The ref value '"+b+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+
(b+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var Q=new Set,D=new Set;z.forEach(function(c,b){var f=c.references;c.isStatic&&D.add(b);f.forEach(function(c){c.writeExpr&&(c=c.writeExpr,Q.has(b)||(Q.add(b),a.report({node:c,message:"Assignments to the '"+b+"' variable from inside React Hook "+(a.getSource(t)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+
(a.getSource(t)+".")})))})});if(!(0<Q.size))if(k){var C=[],N=new Set;"ArrayExpression"!==k.type?a.report({node:k,message:"React Hook "+a.getSource(t)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):k.elements.forEach(function(c){if(null!==c)if("SpreadElement"===c.type)a.report({node:c,message:"React Hook "+a.getSource(t)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{try{var b=Y(c)}catch(M){if(/Unsupported node type/.test(M.message)){"Literal"===c.type?z.has(c.value)?a.report({node:c,message:"The "+c.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(c.value+" in the array instead?")}):a.report({node:c,message:"The "+c.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):a.report({node:c,message:"React Hook "+a.getSource(t)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw M;}for(var f=c;"MemberExpression"===f.type;)f=f.object;var d=!w.through.some(function(a){return a.identifier===f});C.push({key:b,node:c});d||N.add(b)}});var K=W({dependencies:z,declaredDependencies:C,optionalDependencies:D,externalDependencies:N,isEffect:B}),R=K.suggestedDependencies;m=K.unnecessaryDependencies;var H=K.missingDependencies;K=K.duplicateDependencies;if(0===K.size+H.size+m.size)ja({declaredDependencies:C,declaredDependenciesNode:k,componentScope:w,scope:q}).forEach(function(c){var b=
c.fn;c=c.suggestUseCallback;var f="The '"+b.name.name+"' function makes the dependencies of "+(A+" Hook (at line "+k.loc.start.line+") change on every render.");f=c?f+(" To fix this, wrap the '"+(b.name.name+"' definition into its own useCallback() Hook.")):f+(" Move it inside the "+A+" callback. Alternatively, wrap the '"+(b.name.name+"' definition into its own useCallback() Hook."));var d;c&&"Variable"===b.type&&(d=[{desc:"Wrap the '"+b.name.name+"' definition into its own useCallback() Hook.",
fix:function(a){return[a.insertTextBefore(b.node.init,"useCallback("),a.insertTextAfter(b.node.init,")")]}}]);a.report({node:b.node,message:f,suggest:d})});else{!B&&0<H.size&&(R=W({dependencies:z,declaredDependencies:[],optionalDependencies:D,externalDependencies:N,isEffect:B}).suggestedDependencies);(function(){if(0===C.length)return!0;var a=C.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&R.sort();var v="";if(0<m.size){var O=null;Array.from(m.keys()).forEach(function(a){null===
O&&a.endsWith(".current")&&(O=a)});if(null!==O)v=" Mutable values like '"+O+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<N.size){var p=Array.from(N)[0];q.set.has(p)||(v=" Outer scope values like '"+p+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!v&&H.has("props")){q=z.get("props");if(null==q)return;q=q.references;if(!Array.isArray(q))return;p=!0;for(var V=0;V<q.length;V++){var P=Z(w.block,q[V].identifier);
if(!P){p=!1;break}P=P.parent;if(null==P){p=!1;break}if("MemberExpression"!==P.type){p=!1;break}}p&&(v=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(A+" call and refer to those specific props inside ")+(a.getSource(t)+"."))}if(!v&&0<H.size){var S=null;H.forEach(function(a){if(!S){var c=w.set.get(a),b=z.get(a);if(b.references[0].resolved===c&&(c=c.defs[0],null!=c&&null!=c.name&&"Parameter"===c.type)){c=!1;for(var d,
e=0;e<b.references.length;e++)if(d=b.references[e].identifier,null!=d&&null!=d.parent&&"CallExpression"===d.parent.type&&d.parent.callee===d){c=!0;break}c&&(S=a)}}});null!==S&&(v=" If '"+S+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!v&&0<H.size){var u=null;H.forEach(function(a){if(null===u)for(var c=z.get(a).references,b,e,g=0;g<c.length;g++){b=c[g].identifier;for(e=b.parent;null!=e&&e!==w.block;){if("CallExpression"===e.type){var k=
d.get(e.callee);if(null!=k){k.name===a?u={missingDep:a,setter:e.callee.name,form:"updater"}:x.has(b)?u={missingDep:a,setter:e.callee.name,form:"reducer"}:(b=c[g].resolved,null!=b&&(b=b.defs[0],null!=b&&"Parameter"===b.type&&(u={missingDep:a,setter:e.callee.name,form:"inlineReducer"})));break}}e=e.parent}if(null!==u)break}});if(null!==u)switch(u.form){case "reducer":v=" You can also replace multiple useState variables with useReducer if '"+(u.setter+"' needs the current value of '")+(u.missingDep+
"'.");break;case "inlineReducer":v=" If '"+u.setter+"' needs the current value of '"+(u.missingDep+"', you can also switch to useReducer instead of useState and read '")+(u.missingDep+"' in the reducer.");break;case "updater":v=" You can also do a functional update '"+u.setter+"("+u.missingDep.substring(0,1)+" => ...)' if you only need '"+u.missingDep+"' in the '"+(u.setter+"' call.");break;default:throw Error("Unknown case.");}}a.report({node:k,message:"React Hook "+a.getSource(t)+" has "+(F(H,"a",
"missing","include")||F(m,"an","unnecessary","exclude")||F(K,"a","duplicate","omit"))+v,suggest:[{desc:"Update the dependencies array to be: ["+R.join(", ")+"]",fix:function(a){return a.replaceText(k,"["+R.join(", ")+"]")}}]})}}else{var G=null;z.forEach(function(a,e){G||a.references.forEach(function(a){if(!G&&d.has(a.identifier)){for(a=a.from;"function"!==a.type;)a=a.upper;a.block===b&&(G=e)}})});if(G){var aa=W({dependencies:z,declaredDependencies:[],optionalDependencies:D,externalDependencies:new Set,
isEffect:!0}).suggestedDependencies;a.report({node:b.parent.callee,message:"React Hook "+A+" contains a call to '"+G+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+aa.join(", ")+("] as a second argument to the "+A+" Hook."),suggest:[{desc:"Add dependencies array: ["+aa.join(", ")+"]",fix:function(a){return a.insertTextAfter(b,", ["+aa.join(", ")+"]")}}]})}}}}else"useMemo"!==A&&"useCallback"!==A||a.report({node:b.parent.callee,message:"React Hook "+
A+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}}}var g={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0},d=new WeakMap,x=new WeakSet,n=new WeakMap,y=new WeakMap;return{FunctionExpression:b,ArrowFunctionExpression:b}}}}};
